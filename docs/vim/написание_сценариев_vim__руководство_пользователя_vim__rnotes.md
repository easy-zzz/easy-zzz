РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ VIM - Брам Мооленаар

Язык сценариев Vim используется в файле инициализации vimrc, в правилах синтаксиса и во многих других местах. В этой главе объясняются детали использования этого языка. Это будет длинная глава, поскольку язык сценариев Vim имеет огромные возможности.

41.1    [Введение](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#vim-script-intro)  
41.2    [Переменные](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#a41_2)  
41.3    [Выражения](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#a41_3)  
41.4    [Условия](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#a41_4)  
41.5    [Выполнение выражений](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#a41_5)  
41.6    [Использование функций](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#a41_6)  
41.7    [Определение функции](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#a41_7)  
41.8    [Обработка исключительных ситуаций](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#a41_8)  
41.9    [Ряд замечаний](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#a41_9)  
41.10    [Написание модулей](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#write-plugin)  
41.11    [Написание модуля типа файла](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#write-filetype-plugin)  
41.12    [Написание модуля для компилятора](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/143-napisanie-stsenariev-vim.html#write-compiler-plugin)

Следующая глава: [Добавление новых меню](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/144-dobavlenie-novykh-menyu.html)  
Предыдущая глава: [Создание новых команд](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/142-sozdanie-novykh-komand.html)  
Содержание: [Руководство пользователя Vim](https://r-notes.ru/administrirovanie/poleznosti/149-rukovodstvo-polzovatelya-vim-bram-moolenaar.html)

---

#### 41.1 Введение

Впервые со сценариями Vim вы сталкиваетесь в файле vimrc. Vim читает этот файл при запуске и выполняет содержащиеся там команды. С их помощью можно, к  примеру, устанавливать желаемые значения опций. Вообще, в этом файле можно использовать любые команды, начинающиеся с двоеточия, ещё называемые командами Ex или командами командной строки.

Сценариями Vim являются также и файлы с описаниями правил синтаксиса и файлы, которые устанавливают значения опций для определённых типов файлов.  В отдельном файле сценария можно также описывать какие-либо сложные макросы. Вы сами можете придумать какое нибудь еще полезное применение для сценариев Vim.

Начнём с простого примера:

```
:let i = 1:while i < 5:  echo "счётчик равен" i:  let i = i + 1:endwhile
```

**Замечание**: В файле сценария символ ":" не требуется. Он используется обычно для перехода в командную строку в самом редакторе, а в сценариях можно вполне обходиться и без него. Тем не менее, мы будем пользоваться этим символом здесь, чтобы было понятно, что речь идёт о командах Ex, а не командах Обычного режима.

Команда ":let" присваивает значение переменной. Синтаксис этой команды такой:

```
:let {переменная} = {выражение}
```

В данном случае именем переменной является "i", а выражением -- простое значение, 1.

Команда ":while" открывает цикл. Синтаксис этой команды такой:

```
:while {условие}:  {выражения}:endwhile
```

Выражения, указанные до соответствующего ":endwhile" выполняются до тех пор, пока условие является истиной. В нашем примере в качестве условия используется выражение "i < 5". Оно является истиной до тех пор, пока значение переменной i меньше 5.

Команда ":echo" выводит свои аргументы в строке сообщения. В нашем случае аргументами этой команды являются строка "счётчик равен" и значение переменной i. Поскольку i равняется единице, то будет выведено сообщение:

```
счётчик равен 1 ~
```

Затем следует ещё одна команда ":let i =". В качестве значения используется выражение "i + 1". К значению переменной i прибавляется 1 и полученный  
результат присваивается переменной i.

Итак, вывод нашего сценария:

```
счётчик равен 1 ~счётчик равен 2 ~счётчик равен 3 ~счётчик равен 4 ~
```

**Замечание**: Если ваш цикл выполняется бесконечно, то можно остановить его при помощи команды CTRL-C (CTRL-Break на MS-Windows).

###### ТРИ ВИДА ЧИСЕЛ

Числа могут быть десятичные, шестнадцатеричные и восьмеричные. Шестнадцатеричное число начинается с "0x" или "0X". Например, "0x1f" это число 31. Восьмеричное число начинается с нуля. "017" это 15. Будьте внимательны: если вы поместите 0 перед десятичным числом, то оно будет восприниматься как восьмеричное!

Команда ":echo" всегда выводит десятичные числа. Например:

```
     :echo 0x7f 036<    127 30 ~
```

Число может быть отрицательным, если указан знак минус. Это работает также с шестнадцатеричными и восьмеричными числами. Кроме того, знак минус используется для операции вычитания. Сравните с предыдущим примером:

```
     :echo 0x7f -036<    97 ~
```

Пробел внутри выражения игнорируется. В то же время, рекомендуется использовать пробелы для облегчения понимания выражений. Например, чтобы в предыдущем примере не перепутать операцию вычитания со знаком отрицательного числа, поместите между знаком минус и числом пробел:

```
:echo 0x7f - 036
```

---

#### 41.2 Переменные

Имя переменной может состоять из символов ASCII, цифр и символа подчёркивания. Имя не может начинаться с цифры. Вот примеры допустимых имён:

```
counter_aap3very_long_variable_name_with_underscoresFuncLengthLENGTH
```

Имена "foo+bar" и "6var" недопустимы.

Эти переменные являются глобальными. Чтобы посмотреть список текущих глобальных переменных, используйте команду:

```
:let
```

Глобальные переменные можно использовать где угодно. Это означает, что если переменная "count" используется в одном файле сценария, то она также может быть использована и в другом. Это приводит по крайней мере к путанице, но может привести и к серьёзным проблемам. Поэтому, переменные можно сделать также локальными, относящимися только к текущему файлу сценария, путём добавления "s:". Например, представим, что один из сценариев содержит такой код:

```
:let s:count = 1:while s:count < 5:  source other.vim:  let s:count = s:count + 1:endwhile
```

Поскольку "s:count" является локальной переменной, то вы можете быть уверенны, что считывание какого-нибудь другого файла сценария "other.vim" никак не повлияет на значение этой переменной. Если в "other.vim" тоже используется переменная "s:count", то это будет уже совсем другая переменная, локальная по отношению к своему сценарию. Подробнее о локальных переменных сценария см. здесь: |переменные\_сценариев|.

Существуют также и другие виды переменных, см. |внутренние\_переменные|. Наиболее часто употребляются следующие:

<table><tbody><tr><td>b:name</td><td>локальная по отношению к буферу переменная</td></tr><tr><td>w:name</td><td>локальная по отношению к окну переменная</td></tr><tr><td>g:name</td><td>глобальная переменная (в том числе внутри функции)</td></tr><tr><td>v:name</td><td>переменная, предопределённая Vim</td></tr></tbody></table>

###### УДАЛЕНИЕ ПЕРЕМЕННЫХ

Переменные занимают память и появляются в выводе команды ":let". Чтобы удалить переменную, используйте команду ":unlet". Например:

```
:unlet s:count
```

Эта команда удаляет локальную для сценария переменную "s:count" и освобождает занимаемую память. Если вы не уверены, существует ли такая переменная, и не хотите получать сообщение об ошибке в том случае, если такая переменная не существует, то добавьте к команде символ !:

```
:unlet! s:count
```

После завершения сценария использованная локальная переменная не будет удаляться автоматически. При следующем исполнении сценария будет использоваться старое значение. Например:

```
:if !exists("s:call_count"):  let s:call_count = 0:endif:let s:call_count = s:call_count + 1:echo "вызов" s:call_count "раз"
```

Функция "exists()" проверяет, была ли данная переменная уже определена раннее. Аргументом этой функции служит имя переменной, существование которой надо проверить. Обратите внимание -- имя переменной, а не сама переменная! Если вы вместо этого напишите:

```
:if !exists(s:call_count)
```

то в качестве имени переменной будет использоваться значение переменной s:call\_count. Это совсем не то, что вы хотели.

Восклицательный знак ! изменяет значение на обратное. Если значение является истиной, то оно становится ложью. Если значение ложь, то оно становится истиной. Вы можете читать этот символ как слово "не". Иными словами, смысл выражения "if !exists()" можно понять как "если не exists()".

Vim называет истиной всё, что отличается от 0. 0 является ложью.

###### СТРОКОВЫЕ ПЕРЕМЕННЫЕ И КОНСТАНТЫ

До сих пор мы использовали в качестве значения переменной только числа. Однако, можно использовать также и строки. Vim поддерживает только два типа переменных: строки и числа. Тип определяется динамически, иными словами он устанавливается всякий раз, когда выполняется команда присваивания ":let".

Чтобы присвоить строковое значение переменной, вам необходимо использовать строковую константу. Строковые константы бывают двух видов. Во-первых, это строки в дойных кавычках:

```
     :let name = "петя"     :echo name<    петя ~
```

Если вы хотите поместить двойную кавычку внутри строки, то её необходимо экранировать при помощи символа обратной косой черты:

```
     :let name = "\"петя\""     :echo name<    "петя" ~
```

Чтобы избежать необходимости использовать обратную косую черту, можно также пользоваться строками в одинарных кавычках:

```
     :let name = '"петя"'     :echo name<    "петя" ~
```

В строке в одинарных кавычках все символы используются как есть. Как следствие, внутрь такой строки невозможно поместить символ одинарной кавычки. Обратная косая черта в такой строке также воспринимается буквально и не может быть использована для экранирования символа одинарной кавычки или какого угодно другого символа.

В строках в двойных кавычках можно использовать различные специальные символы. Вот несколько наиболее полезных:

<table><tbody><tr><td>\t</td><td>&lt;Tab&gt;</td></tr><tr><td>\n</td><td>&lt;NL&gt;, перенос строки</td></tr><tr><td>\r</td><td>&lt;CR&gt;, &lt;Enter&gt;</td></tr><tr><td>\e</td><td>&lt;Esc&gt;</td></tr><tr><td>\b</td><td>&lt;BS&gt;, удаление символа слева от курсора</td></tr><tr><td>\"</td><td>"</td></tr><tr><td>\\</td><td>\, обратная косая черта</td></tr><tr><td>\&lt;Esc&gt;</td><td>&lt;Esc&gt;</td></tr><tr><td>\&lt;C-W&gt;</td><td>CTRL-W</td></tr></tbody></table>

Последние два примера показывают, как можно использовать форму "\\<имя>" для включения в строку специальной кнопки "имя".

Полный список специальных символов в строках см. в |выражение-кавычки|.

---

#### 41.3 Выражения

В Vim используется простой, и в то же время богатый по возможностям, способ работы с выражениями. Определение этого способа можно прочитать здесь: |выражение-синтаксис|. Остановимся здесь на самых важных моментах.

Числа, строки и переменные сами по себе являются выражениями. Поэтому, везде, где требуется использование выражений, вы можете также использовать число, строку или переменную. Кроме того, в выражении также могут присутствовать следующие основные элементы:

<table><tbody><tr><td>$ИМЯ</td><td>переменная окружения</td></tr><tr><td>&amp;имя</td><td>опция</td></tr><tr><td>@r</td><td>регистр</td></tr></tbody></table>

В качестве примера:

```
:echo "Значение опции 'tabstop':" &ts:echo "Ваш домашний каталог:" $HOME:if @a > 5
```

Форма &имя может также быть использована для сохранения значения опции, установки нового значение и восстановления старого значения после выполнения ряда операций. Пример:

```
:let save_ic = &ic:set noic:/Начало/,$delete:let &ic = save_ic
```

Это позволяет убедиться, что поиск по шаблону "Начало" применяется в регистронезависимом режиме, с выключенной опцией 'ignorecase'. И в то же время, после выполнения команды поиска восстанавливается прежнее значение этой опции.

###### АРИФМЕТИКА

Описанные элементы можно сочетать, и тогда это становится действительно интересно! Попробуем для начала заняться математикой с числами:

<table><tbody><tr><td>a + b</td><td>сложение</td></tr><tr><td>a - b</td><td>вычитание</td></tr><tr><td>a * b</td><td>умножение</td></tr><tr><td>a / b</td><td>деление</td></tr><tr><td>a % b</td><td>остаток</td></tr></tbody></table>

Используется обычный приоритет операций. Пример:

```
     :echo 10 + 5 * 2<    20 ~
```

Элементы можно группировать при помощи скобок. Тоже никаких сюрпризов. Пример:

```
     :echo (10 + 5) * 2<    30 ~
```

Строки можно соединять с помощью ".". Пример:

```
     :echo "лом" . "бард"<    ломбард ~
```

Если команда ":echo" используется с несколькими аргументами, то они разделяются при выводе пробелом. А в только что приведённом примере всего один аргумент, выражение, поэтому пробел не используется.

Из языка C заимствовано условное выражение:

```
a ? b : c
```

Если "a" является истиной, то значением выражения является "b", в ином случае значением является "c" Пример:

```
     :let i = 4     :echo i > 5 ? "i большое" : "i маленькое"<    i маленькое ~
```

В условном выражении всегда прежде всего выясняется значение его составных частей, т.е.:

```
(a) ? (b) : (c)
```

---

#### 41.4 Условия

Команда ":if" выполняет последующие выражения, пока не встретится соответствующая команда ":endif", только в том случае, когда условие выполняется. Общая форма:

```
:if {условие}   {выражения}:endif
```

{выражения} будут выполняться только в том случае, когда значением {условия} является истина (не-ноль). Выражения, конечно, должны быть допустимыми командами. Если в них содержится мусор, то Vim не найдёт соответствующего ":endif".

Вы можете также использовать ":else". В общем виде:

```
:if {условие}   {выражения}:else   {выражения}:endif
```

{выражения} после :else будут выполняться только в том случае, если не выполняются выражения после :if.

Кроме того, также есть ещё команда ":elseif":

```
:if {условие}   {выражения}:elseif {условие}   {выражения}:endif
```

Принцип работы точно такой же, как если бы мы использовали ":else" и затем ":if", но в этом случае не требуется использование дополнительного ":endif".  

Полезный пример для файла vimrc -- проверка значения опции 'term' и выполнение операций в зависимости от этого значения:

```
:if &term == "xterm":  " Выполняем команды для xterm:elseif &term == "vt100":  " Выполняем команды для терминала vt100 :else:  " Выполняем команды для других терминалов:endif
```

###### ЛОГИЧЕСКИЕ ОПЕРАЦИИ

Мы уже использовали некоторые логические операции. Вот наиболее полезные из них:

<table><tbody><tr><td>a == b</td><td>равно</td></tr><tr><td>a != b</td><td>не равно</td></tr><tr><td>a &gt;&nbsp; b</td><td>больше чем</td></tr><tr><td>a &gt;= b</td><td>больше или равно</td></tr><tr><td>a &lt;&nbsp; b</td><td>меньше чем</td></tr><tr><td>a &lt;= b</td><td>меньше или равно</td></tr></tbody></table>

Если условие выполняется, то результат равен 1, иначе результат равен 0. Пример:

```
:if v:version >= 600:  echo "примите поздравления":else:  echo "у вас слишком старая версия, обновите программу!":endif
```

В данном случае используется предопределённая Vim переменная, значение которой равно версии Vim. В версии 6.0 значение переменной v:version равно 600, в версии 6.1 -- 601. Это полезно при написании сценария, который работает с различными версиями Vim. |v:version|

Логические операторы можно употреблять как с числами, так и со строками. При сравнении двух строк используется математическая разность. При этом сравниваются значения байтов, что может быть корректно не для всех языков.

При сравнении строки с числом, строка прежде всего превращается в число. В том случае, если строка не напоминает число, её значением является 0. Пример:

```
:if 0 == "один":  echo "да":endif
```

Этот сценарий выведет "да", поскольку "один" не похоже на число и будет преобразовано в число 0.

Для строк возможны еще две операции:

<table><tbody><tr><td>a =~ b</td><td>совпадает с</td></tr><tr><td>a !~ b</td><td>не совпадает с&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr></tbody></table>

Левая часть, "a", используется как строка. Правая часть, "b", используется как шаблон, такой же шаблон, как и для команды поиска. Пример:

```
:if str =~ " ":  echo "в str встречается пробел":endif:if str !~ '\.$':  echo "str не заканчивается точкой":endif
```

Обратите внимание на использование строки в одинарных кавычках для шаблона. Это может быть полезным, поскольку в строке в двойных кавычках пришлось бы обратную косую черту пришлось бы дублировать, а в шаблонах часто встречается символ обратной косой черты.

При сравнении строк используется опция 'ignorecase'. Если вас это не устраивает, добавьте "#" для учёта регистра символов и "?" для игнорирования регистра. Таким образом, "==?" сравнивает две строки без учёта регистра, а "!~#" проверяет строку на отсутствие соответствия шаблону, принимая во внимание регистр символов. Полную таблицу возможных комбинаций см. в |выражение-==|.

###### ЕЩЁ О ЦИКЛАХ

Команда ":while" уже упоминалась. Между ":while" и ":endwhile" могут быть использованы ещё два выражения:

<table><tbody><tr><td>:continue</td><td>Возвращает управление к началу цикла while; цикл продолжается</td></tr><tr><td>:break</td><td>Переходит к ":endwhile" и прекращает цикл</td></tr></tbody></table>

Пример:

```
:while counter < 40:  call do_something():  if skip_flag:    continue:  endif:  if finished_flag:    break:  endif:  sleep 50m:endwhile
```

Команда ":sleep" устраивает Vim передышку. Значение "50m" указывает на 50 миллисекунд, а ":sleep 4" вызывает паузу в 4 секунды.

---

#### 41.5 Выполнение выражений

До сих пор команды в сценарии выполнялись Vim напрямую. Команда ":execute" представляет очень мощное средство для создания и выполнения команд: она позволяет выполнять результат выражения.

Например, если мы хотим прыгнуть к метке, заключённой в переменной:

```
:execute "tag " . tag_name
```

Мы используем "." для соединения строки "tag " со значением переменной "tag\_name". Если "tag\_name" содержит величину "get\_cmd", то будет выполнена команда:

```
:tag get_cmd
```

Команда ":execute" позволяет выполнять только команды командной строки, начинающиеся с двоеточия. Команда ":normal" выполняет команды Обычного режима. Однако, аргументы этой команды являются не выражением, а буквально символами, из которых состоит команда. Пример:

```
:normal gg=G
```

Эта команда переносит курсор в первую строку и форматирует все строки в тексте при помощи оператора "=".

Чтобы ":normal" можно было выполнять с выражениями, используйте её комбинацию с командой ":execute"":execute". Пример:

```
:execute "normal " . normal_commands
```

В переменной "normal\_commands" должны содержаться команды Обычного режима

Убедитесь, что аргумент ":normal" -- полностью законченная команда. Иначе Vim дойдёт до конца аргумента и прекратит выполнение. В частности, если вы переходите в режим Вставки, то не забудьте вернуться в Обычный режим. Например:

```
:execute "normal Iновый текст \<Esc>"
```

Эта команда позволяет вставить слова "новый текст " в текущей строке. Обратите внимание на использование символов "\\<Esc>" для передачи нажатия на спецкнопку. Это позволяет избежать непосредственного нажатия на кнопку <Esc> во время набора команды сценария.

---

#### 41.6 Использование функций

Vim определяет множество встроенных функций и так существенно расширяет свою функциональность. В этом разделе будет дано несколько примеров. Полный список можно посмотреть здесь: |функции|.

Функция вызывается с помощью команды ":call". Параметры функции передаются внутри скобок, разделённые запятыми. Например:

```
:call search("Дата: ", "W")
```

Эта команда вызывает функцию search(), с аргументами "Дата: " и "W". Первый аргумент функции search() используется в качестве шаблона для поиска, а второй аргумент является флагами поиска. Флаг "W" указывает, что поиск не переходит к началу файла после достижения конца.

Функцию можно вызывать из выражения. Пример:

```
:let line = getline("."):let repl = substitute(line, '\a', "*", "g"):call setline(".", repl)
```

Здесь функция getline() получает строку из текущего файла. Её аргументом является указание на номер строки. В данном случае используется ".", т.е. строка, в которой находится курсор.

Функция substitute() похожа по действию на команду ":substitute". Первым аргументом является строка, в которой выполняется замена. Вторым аргументом является шаблон для замены, третьим -- строка для замены, а последним - флаги.

Функция setline() устанавливает строку, на которую указывает первый аргумент, в значение, указанное вторым аргументом. В этом примере строка под курсором заменяется на результат выполнения функции substitute(). Таким образом, наш сценарий делает то же самое, что и команда:

```
:substitute/\a/*/g
```

Использование функций становится более интересным, если до и после вызова substitute() происходит дополнительная обработка.

###### ФУНКЦИИ

Существует множество функций. Мы приводим здесь список, сгруппированный по их назначению. Алфавитный список можно посмотреть здесь: |функции|. Используйте CTRL-\] на имени функции для получения подробной справки.

<table><tbody><tr><td colspan="2">Работа со строками:</td></tr><tr><td>char2nr()</td><td>получить значение ASCII символа</td></tr><tr><td>nr2char()</td><td>получить символ по значению ASCII</td></tr><tr><td>escape()</td><td>экранировать символы в строке с помощью '\'</td></tr><tr><td>strtrans()</td><td>преобразовать строку в печатный вид</td></tr><tr><td>tolower()</td><td>преобразовать символы в строке в строчные</td></tr><tr><td>toupper()</td><td>преобразовать символы в строке в прописные</td></tr><tr><td>match()</td><td>позиция начала соответствия шаблону в строке</td></tr><tr><td>matchend()</td><td>позиция конца соответствия шаблону в строке</td></tr><tr><td>matchstr()</td><td>соответствие шаблону в строке</td></tr><tr><td>stridx()</td><td>первое соответствие короткой строке в длинной</td></tr><tr><td>strridx()</td><td>последнее соответствие короткой строке в длинной</td></tr><tr><td>strlen()</td><td>длинна строки</td></tr><tr><td>substitute()</td><td>заменить соответствия шаблону на строку</td></tr><tr><td>submatch()</td><td>найти соответствие с ":substitute"</td></tr><tr><td>strpart()</td><td>получить часть строки</td></tr><tr><td>expand()</td><td>заменить специальные символы на их значение</td></tr><tr><td>type()</td><td>тип переменной</td></tr><tr><td>iconv()</td><td>преобразование текста из одной кодировки в другую</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">Работа с текстом в текущем буфере:</td></tr><tr><td>byte2line()</td><td>получить номер строки по номеру байта</td></tr><tr><td>line2byte()</td><td>номер байта в определённой строке</td></tr><tr><td>col()</td><td>номер колонки для курсора или отметки</td></tr><tr><td>virtcol()</td><td>номер колонки экрана для курсора или отметки</td></tr><tr><td>line()</td><td>номер строки для курсора или отметки</td></tr><tr><td>wincol()</td><td>номер колонки окна для курсора</td></tr><tr><td>winline()</td><td>номер строки окна для курсора</td></tr><tr><td>cursor()</td><td>поместить курсор в заданную строку/колонку</td></tr><tr><td>getline()</td><td>получить строку из буфера</td></tr><tr><td>setline()</td><td>заменить строку в буфере</td></tr><tr><td>append()</td><td>добавить {строку} под строкой с {номером}</td></tr><tr><td>indent()</td><td>отступ для определённой строки</td></tr><tr><td>cindent()</td><td>отступ в соответствии с правилами C</td></tr><tr><td>lispindent()</td><td>отступ в соответствии с правилами Lisp</td></tr><tr><td>nextnonblank()</td><td>найти следующую непустую строку</td></tr><tr><td>prevnonblank()</td><td>найти предыдущую непустую строку</td></tr><tr><td>search()</td><td>найти соответствие шаблону</td></tr><tr><td>searchpair()</td><td>найти другой конец пары</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">Системный функции и работа с файлами:</td></tr><tr><td>browse()</td><td>показать диалог для выбора файла</td></tr><tr><td>glob()</td><td>подстановка масок в шаблонах имён файлов</td></tr><tr><td>globpath()</td><td>подстановка масок в шаблонах пути</td></tr><tr><td>resolve()</td><td>найти файл, на который указывает ссылка</td></tr><tr><td>fnamemodify()</td><td>преобразовать имя файла</td></tr><tr><td>executable()</td><td>проверка существования исполняемого файла</td></tr><tr><td>filereadable()</td><td>проверка возможности чтения из файла</td></tr><tr><td>filewritable()</td><td>проверка возможности записи в файл</td></tr><tr><td>isdirectory()</td><td>проверка существования каталога</td></tr><tr><td>getcwd()</td><td>получить имя текущего рабочего каталога</td></tr><tr><td>getfsize()</td><td>получить размер файла</td></tr><tr><td>getftime()</td><td>получить время последнего изменения файла</td></tr><tr><td>localtime()</td><td>получить текущее время</td></tr><tr><td>strftime()</td><td>преобразовать время в строку</td></tr><tr><td>tempname()</td><td>получить имя временного файла</td></tr><tr><td>delete()</td><td>удалить файл</td></tr><tr><td>rename()</td><td>переименовать файл</td></tr><tr><td>system()</td><td>получить результат выполнения команды оболочки</td></tr><tr><td>hostname()</td><td>имя системы</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">Буферы, окна и список файлов-аргументов:</td></tr><tr><td>argc()</td><td>количество аргументов в списке</td></tr><tr><td>argidx()</td><td>текущая позиция в списке аргументов</td></tr><tr><td>argv()</td><td>получить элемент списка аргументов</td></tr><tr><td>bufexists()</td><td>проверка существования буфера</td></tr><tr><td>buflisted()</td><td>проверка существования буфера и его присутствия в списке</td></tr><tr><td>bufloaded()</td><td>проверка существования буфера и состояния его загрузки</td></tr><tr><td>bufname()</td><td>получение имени буфера</td></tr><tr><td>bufnr()</td><td>получение номера буфера</td></tr><tr><td>winnr()</td><td>получение номера текущего окна</td></tr><tr><td>bufwinnr()</td><td>получение номера окна для того или иного буфера</td></tr><tr><td>winbufnr()</td><td>получение номера буфера для определённого окна</td></tr><tr><td>getbufvar()</td><td>получить значение переменной из определённого буфера</td></tr><tr><td>setbufvar()</td><td>установить переменную в определённом буфере</td></tr><tr><td>getwinvar()</td><td>получить значение переменной из определённого окна</td></tr><tr><td>setwinvar()</td><td>установить переменную в определённом окне</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">Складки:</td></tr><tr><td>foldclosed()</td><td>проверка существования закрытой складки в определённой строке</td></tr><tr><td>foldclosedend()</td><td>то же, что и foldclosed(), но с возвратом последней строки</td></tr><tr><td>foldlevel()</td><td>проверка уровня складки в определённой строке</td></tr><tr><td>foldtext()</td><td>строка, отображаемая для закрытой складки</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">Подсветка синтаксиса:</td></tr><tr><td>hlexists()</td><td>проверка существования группы подсветки</td></tr><tr><td>hlID()</td><td>получить ID группы подсветки</td></tr><tr><td>synID()</td><td>получить ID синтаксиса в определённой позиции</td></tr><tr><td>synIDattr()</td><td>получить определённый атрибут для ID синтаксиса</td></tr><tr><td>synIDtrans()</td><td>получить преобразованный ID синтаксиса</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">История:</td></tr><tr><td>histadd()</td><td>добавить элемент в историю</td></tr><tr><td>histdel()</td><td>удалить элемент из истории</td></tr><tr><td>histget()</td><td>получить элемент из истории</td></tr><tr><td>histnr()</td><td>показать максимальный номер в списке истории</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">Интерактивность:</td></tr><tr><td>confirm()</td><td>предложить пользователю выбор</td></tr><tr><td>getchar()</td><td>получить символ от пользователя</td></tr><tr><td>getcharmod()</td><td>получить модификаторы последнего введённого символа</td></tr><tr><td>input()</td><td>получить строку от пользователя</td></tr><tr><td>inputsecret()</td><td>получить строку от пользователя без отображения на экране</td></tr><tr><td>inputdialog()</td><td>получить строку от пользователя в диалоге</td></tr><tr><td>inputresave</td><td>сохранить и очистить упреждающий буфер ввода</td></tr><tr><td>inputrestore()</td><td>восстановить упреждающий буфер ввода</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">сервер Vim:</td></tr><tr><td>serverlist()</td><td>возвращает список имён серверов</td></tr><tr><td>remote_send()</td><td>передать команду на сервер Vim</td></tr><tr><td>remote_expr()</td><td>вычислить выражение на сервере Vim</td></tr><tr><td>server2client()</td><td>отправить ответ сервера Vim клиенту</td></tr><tr><td>remote_peek()</td><td>проверить существование ответа сервера Vim</td></tr><tr><td>remote_read()</td><td>прочитать ответ сервера Vim</td></tr><tr><td>foreground()</td><td>переместить окно Vim на передний план</td></tr><tr><td>remote_foreground()</td><td>переместить окно сервера Vim на передний план</td></tr></tbody></table>

<table><tbody><tr><td colspan="2">Разное:</td></tr><tr><td>mode()</td><td>получить текущий режим редактирования</td></tr><tr><td>visualmode()</td><td>последний использованный Визуальный режим</td></tr><tr><td>hasmapto()</td><td>проверка существования привязки по значению</td></tr><tr><td>mapcheck()</td><td>проверка существования привязки по кнопке</td></tr><tr><td>maparg()</td><td>получение значения привязки</td></tr><tr><td>exists()</td><td>проверка существования переменной, функции&nbsp; и т.п.</td></tr><tr><td>has()</td><td>проверка поддержки особенности данным Vim</td></tr><tr><td>cscope_connection()</td><td>проверка существования соединения с cscope</td></tr><tr><td>did_filetype()</td><td>проверка использования команды FileType</td></tr><tr><td>eventhandler()</td><td>проверка вызова по событию</td></tr><tr><td>getwinposx()</td><td>Координата X окна Vim в графическом интерфейсе</td></tr><tr><td>getwinposy()</td><td>Координата Y окна Vim в графическом интерфейсе</td></tr><tr><td>winheight()</td><td>получить высоту определённого окна</td></tr><tr><td>winwidth()</td><td>получить ширину определённого окна</td></tr><tr><td>libcall()</td><td>вызов функции из внешней библиотеки</td></tr><tr><td>libcallnr()</td><td>то же самое, с возвратом числа</td></tr><tr><td>getreg()</td><td>получить содержимое регистра</td></tr><tr><td>getregtype()</td><td>получить тип регистра</td></tr><tr><td>setreg()</td><td>назначить тип и содержимое регистра</td></tr></tbody></table>

---

#### 41.7 Определение функции

Vim также позволяет определять собственные функции. В общем виде объявление функции выглядит так:

```
:function {имя}({арг1}, {арг2}, ...):  {тело_функции}:endfunction
```

**Замечание**: Имена функций, определённых пользователем, должны начинаться с прописной буквы.

Давайте попробуем определить простую функцию, которая возвращает наименьшее из двух чисел. Определение начинается со строки:

```
:function Min(num1, num2)
```

Это указывает Vim, что мы определяем функцию с именем "Min", которая требует два аргумента: "num1" и "num2".

Прежде всего проверим, какое из чисел меньше:

```
:  if a:num1 < a:num2
```

Приставка "a:" указывает, что мы используем аргумент функции. Давайте присвоим переменной "smaller" значение наименьшего аргумента:

```
:  if a:num1 < a:num2:    let smaller = a:num1:  else:    let smaller = a:num2:  endif
```

Переменная "smaller" является локальной. Все переменные, которые используются внутри функции, являются локальными, за исключением переменных с приставками, такими как "g:", "a:" или "s:".

**Замечание**: Для доступа к глобальной переменной из функции вы должны добавить к её имени приставку "g:". Таким образом, "g:count" внутри функции используется для глобальной переменной "count", а "count" это другая переменная, локальная по отношению к данной функции.

Теперь вам следует использовать команду ":return" для возврата значения наименьшего из двух чисел. После этого нужно закончить определение функции:

```
:  return smaller:endfunction
```

Полное определение функции выглядит так:

```
:function Min(num1, num2):  if a:num1 < a:num2:    let smaller = a:num1:  else:    let smaller = a:num2:  endif:  return smaller:endfunction
```

Вызов функции, определённой пользователем, ничем не отличается от вызова встроенной функции. Различается только имя. Функция Min может быть вызвана так:

```
:echo Min(5, 8)
```

Функция будет исполняться и интерпретироваться Vim только в месте её вызова. Если в теле функции допущены ошибки, например используется неопределённая переменная или функция, то вы получите сообщение об ошибке. При определении функции эта ошибка не будет показана.

Когда выполнение функция достигает команды ":endfunction" или при использовании ":return" без аргумента, функция возвращает 0.

Для переопределения уже существующей функции используйте ! в команде ":function":

```
:function!  Min(num1, num2, num3)
```

###### ИСПОЛЬЗОВАНИЕ ДИАПАЗОНА

Команда ":call" может вызываться со строковым диапазоном. Это может означать две вещи. Во-первых, если функция определена со словом "range", то она позаботится о диапазоне сама.

Функции в этом случае будут переданы автоматически переменный "a:firstline" и "a:lastline". Их значениями будут являться номера строк из диапазона, с которым была вызвана функция. Например:

```
:function Count_words() range:  let n = a:firstline:  let count = 0:  while n <= a:lastline:    let count = count + Wordcount(getline(n)):    let n = n + 1:  endwhile:  echo "найдено " . count . " слов":endfunction
```

Такую функцию можно вызывать, например, так:

```
:10,30call Count_words()
```

Функция будет выполнена один раз и выдаст сообщение о количестве слов.

Во-вторых, можно определить функцию без слова "range". В этом случае функция будет вызвана для каждой строки в диапазоне отдельно, с позицией курсора в очередной строке диапазона. Пример:

```
:function  Number():  echo "строка " . line(".") . " содержит: " . getline("."):endfunction
```

Если вызвать эту функцию так:

```
:10,15call Number()
```

то функция будет вызвана 6 раз.

###### ПЕРЕМЕННОЕ КОЛИЧЕСТВО АРГУМЕНТОВ

Vim позволяет определять функции с переменным количеством аргументов. Например, следующая команда определяет функцию, которая должна иметь один аргумент (start) и может также иметь до 20 дополнительных аргументов:

```
:function Show(start, ...)
```

Переменная "a:1" содержит первый необязательный аргумент, "a:2" второй, и так далее. В переменной "a:0" содержится число дополнительных аргументов.

Например:

```
:function Show(start, ...):  echohl Title:  echo "Show is " . a:start:  echohl None:  let index = 1:  while index <= a:0:    echo "  Arg " . index . " is " . a:{index}:    let index = index + 1:  endwhile:  echo "":endfunction
```

В этой функции используется команда ":echohl" для определения подсветки для последующей команды ":echo". ":echohl None" прекращает указанный режим подсветки. Команда ":echon" работает так же как и ":echo", но не переносит строку.

###### СПИСОК ФУНКЦИЙ

Команда ":function" показывает список имён и аргументов всех определённых пользователем функций:

```
     :function<    функция Show(start, ...) ~     функция GetVimIndent() ~     функция SetSyn(name) ~
```

Чтобы посмотреть, что делает функция, используйте её имя в качестве аргумента для команды ":function":

```
    :function SetSyn<       функция SetSyn(name) ~    1       if &syntax == '' ~    2         let &syntax = a:name ~    3       endif ~        endfunction ~
```

###### ОТЛАДКА

Номер строки может оказаться полезным при отладке или при получении сообщения об ошибке. См. подробнее об отладочном режиме в |отладка\_сценариев|.

Вы также можете установить значение опции 'verbose' в 12 и более, чтобы отслеживать все вызовы функций. Значение 15 и более будет показывать каждую выполняемую строку.

###### УДАЛЕНИЕ ФУНКЦИИ

Чтобы удалить функцию Show():

```
:delfunction Show
```

Если вы пытаетесь удалить несуществующую функцию, то выводится сообщение об ошибке.

---

#### 41.8 Обработка исключительных ситуаций

Для начала приведём пример:

```
:try:   read ~/templates/pascal.tmpl:catch /E484:/:   echo "К сожалению, файл-шаблон для Pascal не найден.":endtry
```

Команда ":read" не сможет быть выполнена, если файл не существует. Вместо того, чтобы выдавать сообщение об ошибке, приведённый выше фрагмент отлавливает ошибку и выдаёт пользователю симпатичное сообщение.

Все команды между ":try" и ":endtry" вместо ошибок выдают исключительные ситуации. Исключительная ситуация это строка. В случае ошибки такой строкой является сообщение об ошибке. Каждое сообщение об ошибке имеет свой номер. В данном случае, мы ловим ошибку, сообщение о которой содержит "E484:". Этот номер не изменится даже в том случае, если изменится сообщение об ошибке - например, оно может быть переведено на другой язык.

Если выполнение команды ":read" приведёт к какой-либо другой ошибке, то шаблон "E484:" не будет ей соответствовать. В результате, возникшая исключительная ситуация не будет обработана, а будет выдано обычное сообщение об ошибке.

У вас может возникнуть соблазн сделать следующее:

```
:try:   read ~/templates/pascal.tmpl:catch:   echo "К сожалению, файл-шаблон для Pascal не найден.":endtry
```

В этом случае будут отлавливаться все ошибки. Однако, в этом случае вы не сможете видеть полезные сообщение об ошибках, например "E21: Изменения невозможны, так как отключена опция 'modifiable'".

Также может быть полезна и команда ":finally":

```
:let tmp = tempname():try:   exe ".,$write " . tmp:   exe "!filter " . tmp:   .,$delete:   exe "$read " . tmp:finally:   call delete(tmp):endtry
```

Этот фрагмент позволяет пропустить фрагмент буфера от текущей строки до конца файла через некую команду "filter", которая в качестве параметра принимает имя файла. Чтобы ни происходило между командами ":try" и ":finally", пусть даже возникнут исключительные ситуации или если пользователь вдруг решит прервать выполнение команды нажатием CTRL-C, команда "call delete(tmp)" будет выполнена. Это позволяет гарантировать, что временный файл будет удалён.

Более подробно об обработке исключительных ситуаций можно прочитать в справочнике: |исключительные\_ситуации-обработка|.

---

#### 41.9 Ряд замечаний

В этом разделе собрано несколько замечаний относящихся к сценариям Vim. Эта информация также разбросана и по другим разделам, но здесь собрана вместе в виде удобного справочника.

Символ конца строки зависит от операционной системы. На Unix это символ <NL>, на MS-DOS, Windows, OS/2 и т.п. используется пара символов <CR><LF>. Это важно при использовании привязок, которые заканчиваются на <CR>. См. |:source\_crnl|.

###### ПРОБЕЛЫ

Пустые строки в сценариях разрешены и игнорируются.

Пробелы в начале строки (пробелы и табуляция) всегда игнорируются. Пробелы между параметрами (например, между 'set' и 'cpoptions' в примере ниже) сокращаются до одного пробела и выполняют роль разделителя. Пробелы в конце строки могут игнорироваться, а могут и нет, в зависимости от конкретной ситуации; подробнее см. ниже.

Для команды ":set", включающей знак "=" (равно), например:

```
:set cpoptions    =aABceFst
```

пробелы перед знаком "=" игнорируются. Однако, после знака "=" пробелов быть не должно!

Для подстановки пробела в значение опции его следует экранировать символом обратной косой черты "\\", как показано в следующем примере:

```
:set tags=мой\ классный\ файл
```

Тот же пример, записанный в виде

```
:set tags=мой классный файл
```

приведёт к возникновению ошибки, поскольку будет интерпретирован как:

```
:set tags=мой:set классный:set файл
```

###### КОММЕНТАРИИ

Символ " (двойная кавычка) обозначает начало комментария. Всё, что набрано после этого символа до конца строки, включая сам этот символ, игнорируется, за исключением команд, которые не допускают комментариев, как это показано на примере ниже. Комментарий может начинаться в любой позиции строки.

Некоторые команды не допускают комментариев. Примеры:

```
:abbrev dev development        " сокращение:map <F3> o#include            " вставить include:execute cmd                   " выполнить:!ls *.c                       " показать файлы C
```

Сокращение 'dev' будет преобразовано в 'development     " сокращение'. Привязка для <F3> будет осуществляться для всей строки после 'o# ....', включая '" вставить include'.  Команда "execute" выдаст ошибку.  Команда "!" отправит в оболочку всё, что следует после неё, что приведёт к ошибке оболочки, поскольку " не закрыта.

Комментарии невозможны после команд ":map", ":abbreviate", ":execute" и "!", а также ряда других команд. Для команд ":map", ":abbreviate" и ":execute" можно использовать комментарий так:

```
:abbrev dev development|" сокращение:map <F3> o#include|" вставить include:execute cmd            |" выполнить
```

При помощи символа '|' одна команда отделяется от другой, которой в этом случае является комментарий.

Обратите внимание, что перед '|' в командах для сокращения и привязки нет пробела. В этих командах используются все символы, которые встречаются до символа '|' или конца строки. Как следствие, вы не всегда видите лишние пробелы в этих командах:

```
:map <F4> o#include  
```

Чтобы избежать таких проблем, включайте опцию 'list' при редактировании файлов типа vimrc.

###### ПОДВОДНЫЕ КАМНИ

В показанном ниже примере возникает ещё более серьёзная проблема:

```
:map ,ab o#include:unmap ,ab
```

Команда unmap в данном случае работать не будет, поскольку она пытается удалить привязку для ",ab ", которой не существует. Такую ошибку очень сложно обнаружить, поскольку пробел на конце ":unmap ,ab " не заметен.

При использовании комментария после команды 'unmap' происходит то же самое:

```
:unmap ,ab     " комментарий
```

В данном случае комментарий игнорируется, однако Vim будет пытаться удалить привязку для ',ab     ', которой не существует. Переписать такую команду правильно можно так:

```
:unmap ,ab|    " комментарий
```

###### ВОССТАНОВЛЕНИЕ ВИДА

Иногда вы хотите внести изменение и вернуться к прежнему положению курсора. Было бы неплохо при этом также восстанавливать положение относительно окна, т.е. чтобы при восстановлении положения вверху окна появлялась та же самая строка.

Пример, приведённый ниже, копирует текущую строку, помещает её над первой строкой в файле, и затем восстанавливает вид экрана:

```
map ,p ma"aYHmbgg"aP`bzt`a
```

Вот что при этом происходит:

<table><tbody><tr><td>ma"aYHmbgg"aP`bzt`a</td><td>&nbsp;</td></tr><tr><td>ma</td><td>установить отметку a в позиции курсора</td></tr><tr><td>&nbsp; "aY</td><td>скопировать текущую строку в регистр a</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp; Hmb</td><td>перейти в верхнюю строку окна и установить отметку b в этой строке</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gg</td><td>перейти в первую строку файла</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "aP</td><td>вклеить скопированную строку над первой строкой</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `b</td><td>вернуться к позиции верхней строки в окне</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zt</td><td>поместить текст в окне как это было раньше</td></tr><tr><td nowrap="nowrap">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `a</td><td>переместить курсор в сохранённую раннее позицию</td></tr></tbody></table>

###### УПАКОВКА ИМЁН

Чтобы имена функций не входили в конфликт с другими функциями, используйте такую схему:

+   Добавьте уникальную строку перед каждым именем функции. Я часто пользуюсь сокращением. Например, "OW\_" используется для функций, относящихся к окну опций.
+   Поместите определение функций в одном файле. Установите глобальную переменную, указывающую на то, что функции были загружены. При повторной загрузке файла, прежде всего выгрузите уже загруженные функции.

Пример:

```
" Пакет XXXif exists("XXX_loaded")  delfun XXX_one  delfun XXX_twoendiffunction XXX_one(a)    ... тело функции ...endfunfunction XXX_two(b)    ... тело функции ...endfunlet XXX_loaded = 1
```

---

#### 41.10 Написание модулей

Вы можете написать сценарий Vim с тем, чтобы им могли пользоваться многие пользователи. Такой сценарий называется модулем. Пользователи Vim могут поместить ваш модуль в свой каталог plugin и использовать его возможности.  См. |добавление\_модуля|.

Вообще, существует два вида модулей:

+   общие модули: Используются для всех типов файлов
+   модули типа файла: Используются только для определённых типов файла

В этом разделе мы рассмотрим модули первого типа. Большинство из рассмотренного материала также применимо и к написанию модулей типов файлов. Особенности модулей типа файла рассматриваются в следующем разделе, см. |написание\_модулей\_типа\_файла|.

###### ИМЯ

Прежде всего следует выбрать имя для вашего модуля. Имя должно ясно указывать на особенности модуля и, кроме того, должно быть маловероятно, что кто-то напишет модуль с таким-же именем, но выполняющий совершенно иные действия. Чтобы избежать проблем на старых системах Windows, ограничьтесь 8 символами при выборе имени для модуля.

В качестве примера мы будем пользоваться сценарием, который позволяет исправлять опечатки. Мы назовём его "typecorr.vim".

Чтобы модуль работал у всех пользователей, необходимо придерживаться ряда рекомендаций. Мы объясним здесь всё шаг за шагом, а полный текст модуля приведём в конце раздела.

###### ТЕЛО МОДУЛЯ

Начнём с тела модуля, т.е строк, которые выполняют непосредственно работу в нашем сценарии:

```
14    iabbrev teh the15    iabbrev otehr other16    iabbrev wnat want17    iabbrev synchronisation18        \ synchronization19    let s:count = 4
```

Конечно, список может быть и более длинным.

Номера строк здесь добавлены только для объяснения некоторых особенностей. Не помещайте их в файл сценария!

###### ЗАГОЛОВОК

Скорее всего вы будете вносить исправления в модуль и вскоре у вас появится несколько версий. При распространении этого файла люди захотят узнать, кто написал этот замечательный модуль и кому они могут отправить свои комментарии. Поэтому, вверху модуля поместим заголовок:

```
 1    " Общий модуль Vim для исправления опечаток 2    " Последнее изменение:    2000 Oct 15 3    " Автор:        Bram Moolenaar <Bram@vim.org>;
```

О лицензиях и авторском праве: поскольку модули могут быть крайне полезными, а ограничивать их распространение вряд ли имеет смысл, подумайте о том, чтобы либо сделать их общественным достоянием, либо распространять по лицензии Vim |license|. Короткого замечания в самом начале файла модуля вполне достаточно. Например:

```
  4    " Лицензия:        Этот файл является общественным достоянием.
```

###### ПРОДОЛЖЕНИЕ СТРОКИ, УСТРАНЕНИЕ ПОБОЧНЫХ ЭФФЕКТОВ

В строке 18 используется механизм продолжения строки |продолжение\_строки|. Пользователи, работающие в совместимом с Vi режиме (с включённой опцией 'compatible') столкнуться в этом месте с проблемами. Мы не можем отключить опцию 'compatible', поскольку это вызовет целый ряд нежелательных последствий для пользователя. Чтобы их избежать, мы установим опцию 'cpoptions' в её значение по умолчанию и затем восстановим её прежнее значение. Это позволит использовать продолжение строк и модулем смогут пользоваться многие люди. Это делается следующим образом:

```
11    let s:save_cpo = &cpo12    set cpo&vim..41    let &cpo = s:save_cpo
```

Прежде всего мы сохраняем старое значение опции 'cpoptions' в переменной s:save\_cpo. В конце выполнения модуля это значение будет восстановлено.

Обратите внимание на использование локальной по отношению к сценарию переменной |s:var|. Глобальная переменная может быть уже использована для других целей. Для значений, которые используются только внутри модуля, всегда применяйте локальные переменные.

###### ОТКАЗ ОТ ЗАГРУЗКИ

Возможно, пользователь не всегда захочет загружать данный модуль. Или системный администратор поместил его в общий для всех пользователей каталог,  а какой-либо пользователь хочет использовать вместо него собственный модуль.  У пользователя должна быть возможность не загружать данный модуль. Это возможно благодаря следующим строкам:

```
6    if exists("loaded_typecorr")7      finish8    endif9    let loaded_typecorr = 1
```

Это также позволяет избежать ошибок о переопределении функций и повторном выполнении автокоманд при повторной загрузке модуля.

###### ПРИВЯЗКИ

Теперь сделаем наш модуль немного интереснее: добавим привязку, выполняющую добавление опечатки к списку в слове, расположенном под курсором. Мы могли бы просто назначить такую привязку для первой понравившейся нам клавиши, но пользователь может уже повесить на эту клавишу свою собственную привязку. Чтобы пользователь мог сам определить клавишу для привязки, воспользуемся элементом <Leader>:

```
22      map <unique> <Leader>a  <Plug>TypecorrAdd
```

Элемент "<Plug>TypecorrAdd" будет выполнять требуемую работу, подробнее об этом читайте ниже.

Пользователь может установить значение переменной "mapleader" в последовательность клавиш, которые будут использованы в начале привязки. Например, если пользователь введёт:

```
let mapleader = "_"
```

то привязка будет определена как "\_a". В противном случае будет использовано значение по умолчанию, обратная косая черта, т.е. будет определена привязка для "\\a".

Обратите внимание, что используется <unique>, а значит при попытке переопределения существующей привязки появится сообщение об ошибке. |:map-<unique>|

Но что если пользователь пожелает определить собственную последовательность кнопок? Это можно организовать при помощи такого механизма:

```
21    if !hasmapto('<Plug>TypecorrAdd')22      map <unique> <Leader>a  <Plug>TypecorrAdd23    endif
```

Иными словами, мы проверяем, существует ли привязка для значения "<Plug>TypecorrAdd" и определяем привязку для "<Leader>a" только в том случае, если она не существует. В этом случае пользователь может поместить в свой файл vimrc:

```
map ,c  <Plug>TypecorrAdd
```

чтобы последовательность кнопок для привязки вместо "\_a" или "\\a" была ",c".

###### ФРАГМЕНТЫ

Если сценарий становится длинным, то работу над ним можно разбить на отдельные фрагменты. Для этой цели можно использовать функции или привязки. Однако, такие функции и привязки не должны входить в конфликт с другими сценариями. Например, вы можете определить функцию Add(), которая также может быть определена и в другом сценарии. Чтобы этого избежать, определим функцию как локальную по отношению к данному сценарию при помощи приставки "s:".

Итак, определим функцию, которая добавляет новую опечатку:

```
30    function s:Add(from, correct)31      let to = input("type the correction for " . a:from . ": ")32      exe ":iabbrev " . a:from . " " . to..36    endfunction
```

Теперь мы можем вызывать из данного сценария функцию s:Add(). Если другой сценарий также определяет функцию s:Add(), то она будет локальной для того сценария, из которого вызывается. Кроме того, может быть определена глобальная функция Add() (без приставки "s:"), которая также будет отдельной функцией.

В привязках можно использовать <SID>. <SID> это величина, которая уникальна для данного сценария и позволяет его идентифицировать. В нашем случае мы можем использовать <SID> так:

```
24    noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add..28    noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
```

Теперь, когда пользователь вводит "\\a", то выполняются следующие действия:

```
\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()
```

В случае, если другой сценарий также использует привязку для <SID>Add, то это будет уже иная привязка, с другим идентификатором сценария.

Обратите внимание, что здесь используется <SID>Add() вместо s:Add(). Это связано с тем, что привязка вводится пользователем, вне файла сценария. <SID> преобразуется в идентификатор сценария, поэтому Vim знает в каком сценарии надо искать функцию Add().

Хотя всё это и выглядит немного сложным, такой механизм требуется, чтобы модуль корректно работал с другими модулями. Основное правило состоит в том, чтобы использовать <SID>Add() в привязках, и s:Add() в остальных местах (в самом сценарии, в автокомандах, командах пользователя).

Мы также можем добавить пункт меню для выполнения тех же функций:

```
26    noremenu <script> Модули.Добавить\ исправление      <SID>Add
```

Для добавления относящихся к модулям элементов рекомендуется использовать меню "Модули". В данном случае используется только один элемент. При использовании нескольких элементов рекомендуется создать подменю. Например, "Модули.CVS" можно использовать для модуля, который использует операции CVS "Модули.CVS.поместить", "Модули.CVS.забрать" и т.п.

Обратите внимание, что в строке 28 используется ":noremap" во избежание проблем с другими привязками. Например, кто-то может пожелать переопределить привязку для ":call". В строке 24 мы также используем :noremap", но при этом мы хотим позволить переопределение привязки для "<SID>Add". Вот почему в этом случае мы используем слово "<script>". Это позволяет использовать только привязки, которые определены как локальные для данного сценария. |:map-<script>| Аналогичная операция выполняется и в строке 26 для ":noremenu". |:menu-<script>|

###### <SID> И <Plug>

Как <SID>, так и <Plug> используются для того, чтобы избежать конфликта привязок вводимых символов с привязками, которые используются только в других привязках. Обратите внимание на различия между <SID> и <Plug>:

+   **<Plug>** видно за пределами сценария. Это слово используется для привязок, к которым пользователь может присвоить собственную последовательность символов. <Plug> образует специальный код, который нельзя воспроизвести нажатием на клавиши.  Чтобы свести возможность ситуации, когда другие модули используют ту же последовательность символов, применяйте такую структуру: <Plug> имя\_сценария имя\_привязки. В нашем примере имя сценария будет "Typecorr", а имя привязки "Add". В результате получается "<Plug>TypecorrAdd". Чтобы выделить, где начинается имя привязки, мы используем в качестве первого символа прописную букву.
+   **<SID>** это уникальный идентификатор сценария, его ID. Внутри Vim <SID> преобразуется в нечто похожее на "<SNR>123\_", где "123" может быть любым числом. Таким образом, функция "<SID>Add()" может иметь в одном сценарии имя "<SNR>11\_Add()" и имя "<SNR>22\_Add()" в другом сценарии. Вы можете это заметить, если посмотрите на вывод списка определённых функций по команде ":function". Преобразование <SID> в привязках происходит точно так же, поэтому вы можете вызывать из привязки локальную по отношению к сценарию функцию.

###### КОМАНДЫ ДЛЯ ПОЛЬЗОВАТЕЛЯ

Теперь добавим команду для добавления исправления:

```
38    if !exists(":Correct")39      command -nargs=1  Correct  :call s:Add(<q-args>, 0)40    endif
```

Эта команда пользователя будет определена только в том случае, если ещё не существует команды с данным именем. Иначе мы могли бы столкнуться с сообщением об ошибке. Насильное переопределение команды с помощью ":command!" не самая лучшая идея, поскольку пользователь будет недоволен, если его команда работает не так, как ему надо.  |:command|

###### ПЕРЕМЕННЫЕ В СЦЕНАРИИ

Если переменная начинается с приставки "s:", то это сценарная переменная. Она может быть использована только внутри сценария. Вне сценария эта переменная никак себя не проявляет. Это позволяет избежать проблем с использованием переменных с одинаковым именем в разных сценариях. Переменные сохраняются на протяжении всего сеанса работы Vim. При повторном считывании того же самого сценария будут использованы те же самые переменные.  |s:переменная|

Эти переменные могут быть свободно использованы в функциях, автокомандах и командах пользователя, определённых в сценарии. В нашем примере можно добавить несколько строк, которые будут подсчитывать число исправлений:

```
19    let s:count = 4..30    function s:Add(from, correct)..34      let s:count = s:count + 135      echo s:count . " исправлений в списке"36    endfunction
```

В начале выполнения сценария s:count равняется 4. Затем, при вызове функции s:Add() мы увеличиваем значение s:count на единицу. Не имеет значения, откуда вызвана функция s:Add() -- будут использованы локальные по отношению к сценарию переменные, поскольку сама функция определена внутри сценария.

###### РЕЗУЛЬТАТ

Вот полный текст нашего модуля:

```
 1    " Общий модуль Vim для исправления опечаток 2    " Последнее изменение:    2000 Oct 15 3    " Автор:        Bram Moolenaar <Bram@vim.org>; 4    " Лицензия:     Этот файл является общественным достоянием. 5 6    if exists("loaded_typecorr") 7      finish 8    endif 9    let loaded_typecorr = 11011    let s:save_cpo = &cpo12    set cpo&vim1314    iabbrev teh the15    iabbrev otehr other16    iabbrev wnat want17    iabbrev synchronisation18        \ synchronization19    let s:count = 42021    if !hasmapto('<Plug>TypecorrAdd')22      map <unique> <Leader>a  <Plug>TypecorrAdd23    endif24    noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add2526    noremenu <script> Модули.Добавить\ исправление      <SID>Add2728    noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>2930    function s:Add(from, correct)31      let to = input("type the correction for " . a:from . ": ")32      exe ":iabbrev " . a:from . " " . to33      if a:correct | exe "normal viws\<C-R>\" \b\e" | endif34      let s:count = s:count + 135      echo s:count . " corrections now"36    endfunction3738    if !exists(":Correct")39      command -nargs=1  Correct  :call s:Add(<q-args>, 0)40    endif4142    let &cpo = s:save_cpo
```

Смысл строки 33 еще не объяснялся. Она применяет новое исправление к слову, находящемуся под курсором. Для применения нового сокращения используется команда |:normal|. Обратите внимание, что несмотря на то, что мы вызываем привязку, определённую с помощью ":noremap", в этом случае выполняется подстановка для привязок и сокращений.

Для файлов модулей рекомендуется использовать "unix" в качестве значение опции 'fileformat'. В этом случае сценарий будет работать везде. Сценарии, сохранённые со значением опции 'fileformat' равным "dos", не будут работать на Unix. См. также |:source\_crnl|. Чтобы быть уверенным, что всё правильно, перед записью введите команду:

```
:set fileformat=unix
```

###### ДОКУМЕНТАЦИЯ

Для модуля всегда неплохо также написать краткий файл справки, особенно в тех случаях, когда действие модуля может изменяться пользователем. Подробнее о том, как установить файл справки, читайте в |добавление\_файла\_справки|.

Вот пример справки для нашего модуля, названный "typecorr.txt":

```
 1    *typecorr.txt*    Модуль для исправления опечаток 2 3    Если вы допускаете при наборе текста опечатки, то этот модуль 4     позволяет исправлять их автоматически. 5 6    Модуль распознаёт лишь несколько типичных опечаток. При желании 7     вы можете добавить свои. 8 9    Привязки:10    <Leader>a   или   <Plug>TypecorrAdd11        Добавляет исправление для слова, находящегося под курсором.1213    Команды:14    :Correct {слово}15        Добавить исправление для {слова}.1617                            *typecorr-настройки*18    Этот модуль не имеет настроек.
```

Первая строка -- единственная, для которой имеет значение определённый формат. Эта строка будет размещена в разделе "МЕСТНЫЕ ДОПОЛНЕНИЯ:" файла help.txt (см. |local-additions|). Первая "\*" должна находиться в первой колонке первой строки. После добавления файла справки выполните команду ":help" и убедитесь, что записи красиво выровнены друг против друга.

Внутри файла справки вы можете добавлять собственные метки внутри \*\*. Однако, будьте внимательны, чтобы не использовать уже определённые раннее метки. Лучше всего использовать внутри метки имя модуля, как в нашем примере: "typecorr-настройки".

Рекомендуется также использовать |вертикальные\_линии| для указания ссылок на другие части справочной системы. Это позволяет пользователю легко находить необходимую ему справку.

###### РАСПОЗНАВАНИЕ ТИПА ФАЙЛА

Если у вас имеется файл, тип которого ещё не распознаётся Vim, то вам следует создать в отдельном файле сценарий определения типа файла. Обычно это специальная автокоманда, которая задаёт тип файла при обнаружении соответствия имени файла шаблону. Например:

```
au BufNewFile,BufRead *.foo                     set filetype=foofoo
```

Поместите файл, в котором содержится похожая строчка в первый каталог по пути, заданному в опции 'runtimepath'. В Unix это может быть файл с именем "~/.vim/ftdetect/foofoo.vim".  Соглашение указывает, что в качестве имени сценария следует использовать имя типа файла.

При желании вы можете выполнять и более сложные проверки в сценарии определения типа файла, например проверять содержимое файла для распознавания языка программирования, на котором он написан. См. также |новый\_тип\_файла|.

###### РЕЗЮМЕ

Перечислим специальные элементы, которые используются в модулях:

<table><tbody><tr><td>s:name</td><td>Переменные, локальные по отношению к сценарию</td></tr><tr><td>&lt;SID&gt;</td><td>Идентификатор сценария, используется для привязок и функций, локальных по отношению к сценарию.</td></tr><tr><td>hasmapto()</td><td>Функция, проверяющая наличие привязки для данного значения, которое предлагается сценарием.</td></tr><tr><td>&lt;Leader&gt;</td><td>Значение переменной "mapleader" для определения начала привязки для данного модуля.</td></tr><tr><td>:map &lt;unique&gt;</td><td>Выдаёт предупреждение, если привязка уже существует.</td></tr><tr><td>:noremap &lt;script&gt;</td><td>Использовать только локальные по отношению к данному сценарию привязки, а не глобальные</td></tr><tr><td>exists(":Cmd")</td><td>Проверка существования команды пользователя.</td></tr></tbody></table>

---

#### 41.11 Написание модуля типа файла

Модуль типа файла похож на модуль общего назначения, с тем исключением, что он устанавливает опции и определяет привязки только для текущего буфера. Подробнее об использовании таких модулей см. в |добавление\_модуля\_типа\_файла|.

Прочитайте внимательно раздел об общих модулях, |41.10|. Всё, что сказано в этом разделе, относится также и к модулям типа файла. Ряд дополнительных особенностей будет изложен в этом разделе. Самое главное, что необходимо усвоить, это то, что модуль типа файла должен работать только в текущем буфере.

###### ОТКЛЮЧЕНИЕ МОДУЛЯ

Если вы пишите модуль типа файла для использования многими людьми, то необходимо предоставить им возможность отключения этого модуля. Поэтому, в начале модуля следует поместить такой код:

```
" Выполнять только в том случае, если еще не сделано для данного" буфераif exists("b:did_ftplugin")  finishendiflet b:did_ftplugin = 1
```

Это также позволяет избежать выполнения одного и того же модуля второй раз для данного буфера, что может происходить при использовании команды ":edit" без аргументов.

Теперь пользователи могут отключить загрузку этого модуля, создав свой модуль типа файла с одной-единственной строкой:

```
let b:did_ftplugin = 1
```

Это, однако, требует, чтобы каталог с модулями типов файла был указан до каталога $VIMRUNTIME в 'runtimepath'!

Если вы хотите использовать основной модуль для данного типа файлов, но желаете изменить несколько настроек, то вы можете указать свои настройки в файле сценария:

```
setlocal textwidth=70
```

Поместите ваш сценарий в каталог "after", чтобы он мог быть прочитан редактором после того, как будет загружен стандартный модуль типа файла "vim.vim" |after-каталог|. На Unix это будет "~/.vim/after/ftplugin/vim.vim". Обратите внимание, что стандартный модуль установит переменную "b:did\_ftplugin", так что при повторной загрузке ничего не произойдёт.

###### ОПЦИИ

Чтобы быть уверенным в том, что модуль типа файла затрагивает только текущий буфер, используйте для установки значения опций команду

```
:setlocal
```

и используйте только локальные по отношению к данному буферу опции (не ленитесь заглядывать в справочник). При использовании |:setlocal| для глобальных опций или опций, которые являются локальными по отношению к окну, значение будет изменяться для других буферов, а модуль типа файла не должен этого делать.

При использовании опций, значение которых представлено списком нескольких элементов или флагов, подумайте о возможности использования "+=" и "-=" для сохранения других существующих значений. Имейте в виду, что пользователь может уже изменить значение той или иной опции. Часто может потребоваться сброс значения опции к значению, используемому по умолчанию, и затем установке дополнительных значений опции. Пример: >

```
:setlocal formatoptions& formatoptions+=ro
```

###### ПРИВЯЗКИ

Чтобы быть уверенным в том, что привязки будут работать только в текущем буфере, используйте команду

```
:map <buffer>
```

Это необходимо комбинировать с объяснённым выше способом организации привязок. Пример определения функциональности в модуле типа файла:

```
if !hasmapto('<Plug>JavaImport')  map <buffer> <unique> <LocalLeader>i <Plug>JavaImportendifnoremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>
```

|hasmapto()| используется для проверки существования привязки для значения <Plug>JavaImport. Если привязки не существует, то используется привязка по умолчанию. Эта привязка начинается со слова |<LocalLeader>|, которое позволяет пользователю выбрать клавиши, с которых должны начинаться привязки для модулей данного типа файла. Значением по умолчанию является символ обратной косой черты.

Слово <unique> используется для вывода сообщения об ошибке в том случае, если привязка уже существует, или конфликтует с другой существующей привязкой. |:noremap| используется во избежание конфликта с другими привязками, определёнными пользователем. Вы можете использовать ":noremap <script>" для того, чтобы позволить переопределение привязок, начинающихся с <SID> в данном сценарии.

У пользователя должна быть возможность отключения привязок, определённых модулем типа файла, без необходимости отключения всех привязок. Приведём пример того, как это можно сделать в модуле для почтового файла:

```
" Добавить привязки, если пользователь не возражает.if !exists("no_plugin_maps") && !exists("no_mail_maps")  " Цитировать текст при помощи "> "  if !hasmapto('<Plug>MailQuote')    vmap <buffer> <LocalLeader>q <Plug>MailQuote    nmap <buffer> <LocalLeader>q <Plug>MailQuote  endif  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>endif
```

Используется две глобальные переменные:

<table><tbody><tr><td>no_plugin_maps</td><td>отключает привязки для всех модулей типа файла</td></tr><tr><td>no_mail_maps</td><td>отключает привязки для определённого модуля типа файла</td></tr></tbody></table>

###### КОМАНДЫ ПОЛЬЗОВАТЕЛЯ

Для добавления команды пользователя для определённого типа файла, чтобы она могла быть использована только в данном буфере, используйте аргумент "-buffer" для команды |:command|. Пример:

```
:command -buffer  Make  make %:r.s
```

###### ПЕРЕМЕННЫЕ

Модуль типа файла считывается для каждого буфера с данным типом файла. Локальные переменные |s:переменная| используются всеми модулями данного типа совместно. Если вы хотите использовать какую-либо переменную строго в пределах данного буфера, то используйте буферные переменные |b:переменная|.

###### ФУНКЦИИ

Определение функции требуется выполнять только один раз. Поскольку модуль типа файла считывается всякий раз, когда открывается файл с данным типом файла, то следует пользоваться следующей конструкцией:

```
:if !exists("*s:Func"):  function s:Func(arg):    ...:  endfunction:endif
```

###### ОТМЕНА

Если пользователь вводит команду вроде ":setfiletype xyz", то эффект предыдущего определения типа должен быть отменён. Для этого можно установить значение переменной b:undo\_ftplugin равным списку команд, которые должны быть выполнены, чтобы отменить действие модуля типа файла. Например:

```
let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"    \ . "| unlet b:match_ignorecase b:match_words b:match_skip"
```

Использование команды ":setlocal" с символом "<" после имени опции позволяет вернуть опции её глобальное значение. Это как правило самый лучший способ восстановить значение опции.

Этот пример требует, чтобы в значении 'cpoptions' не было флага "C", чтобы разрешить продолжение строки, как об этом говорилось выше |use-cpo-save|.

###### ИМЯ ФАЙЛА

Тип файла должен быть отображён в имени файла модуля,  см. |модуль\_типа\_файла-имя|. Вы можете использовать одну из трёх форм:

```
.../ftplugin/stuff.vim.../ftplugin/stuff_foo.vim.../ftplugin/stuff/bar.vim
```

здесь "stuff" указывает на тип файла, а "foo" и "bar" это произвольные имена.

РЕЗЮМЕ

Перечислим специальные элементы, которые используются в модулях типа файла:

<table><tbody><tr><td>&lt;LocalLeader&gt;</td><td>Значение переменной "maplocalleader", с помощью которой пользователь определяет клавиши, с которых начинаются привязки для модулей типа файла.</td></tr><tr><td>:map &lt;buffer&gt;</td><td>Определить локальную для данного буфера привязку.</td></tr><tr><td>:noremap &lt;script&gt;</td><td>Допускать только переопределение привязок, которые в модуле начинаются с &lt;SID&gt;.</td></tr><tr><td>:setlocal</td><td>Установить опции только для текущего буфера.</td></tr><tr><td>:command -buffer</td><td>Определить команду пользователя локально для данного буфера.</td></tr><tr><td>exists("*s:Func")</td><td>Проверяет существование данной функции.</td></tr></tbody></table>

См. также |модули-специальные\_элементы| для получения информации об элементах, которые применяются во всех модулях.

---

#### 41.12 Написание модуля для компилятора

Модуль для компилятора настраивает опции для использования с определённым компилятором. Пользователь загружает такой модуль при помощи команды |:compiler|. Его основное предназначение состоит в настройке значения опций 'errorformat' и 'makeprg'.

Проще всего показать это на примере. Вот команда, которая позволяет редактировать все стандартные модули для компиляторов:

```
:next $VIMRUNTIME/compiler/*.vim
```

Для перехода к следующему модулю используйте команду |:next|.

Эти модули имеют две особенности. Во-первых, механизм, с помощью которого пользователь может переопределять или добавлять значения к используемому по умолчанию файлу. В модулях, которые применяются по умолчанию, в самом начале выполняются следующие команды:

```
:if exists("current_compiler"):  finish:endif:let current_compiler = "mine"
```

Если вы напишите свой сценарий для компилятора и поместите его в личный каталог для этих модулей (на Unix это, например, ~/.vim/compiler), то в этом файле вам нужно будет установить переменную "current\_compiler", чтобы не загружать сценарий, используемый для данного компилятора по умолчанию.

Второй механизм заключается в применении ":set" при выполнении команды ":compiler!" и ":setlocal" при выполнении команды ":compiler". Vim определяет для этого пользовательскую команду ":CompilerSet". Однако, старые версии Vim этого не делают, и в этом случае вам придётся определить эту команду самостоятельно. Приведём пример:

```
if exists(":CompilerSet") != 2    command -nargs=* CompilerSet setlocal <args>endifCompilerSet errorformat&            " использовать значение опции                                     " 'errorformat' по умолчаниюCompilerSet makeprg=nmake
```

Используйте описанный выше механизм для написании модуля компилятора, который используется по умолчанию в системе или распространяется в комплекте поставки Vim. Если пользователь определит переменную "current\_compiler" в собственном модуле, то системный модуль считываться не будет.

Если ваш модуль для компилятора только изменяет некоторые настройки модуля, который используется по умолчанию, то вам не следует проверять в нём значение  переменной "current\_compiler". Такой модуль будет загружаться в последнюю очередь, поэтому он должен находиться в каталоге, указанном в 'runtimepath' в самом конце. В Unix это может быть ~/.vim/after/compiler.

---

Следующая глава: [Добавление новых меню](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/144-dobavlenie-novykh-menyu.html)  
Авторские права: см. [Авторские права](https://r-notes.ru/48-knigi/rukovodstvo-polzovatelya-vim/118-o-dokumentatsii.html#manual-copyright)