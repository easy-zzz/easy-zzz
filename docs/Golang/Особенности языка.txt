Особенности языка — Яндекс Практикум

Тема 1/4: История и идеология Go → Урок 2/4

Особенности языка

Go — это компилируемый язык программирования со строгой статической типизацией, сборщиком мусора и встроенным менеджером пакетов. Он разработан с упором на многопоточное программирование.

В основе идеологии Go лежат минималистичность, простота синтаксиса, высокая скорость сборки и выполнения, удобные абстракции для написания многопоточного кода и эффективная утилизация всех доступных ядер процессора. 

На что похож синтаксис Go?

В Go C-подобный синтаксис с минимумом неочевидных и неявных конструкций. Поощряется читаемость и чистота кода — для этого используется компилятор, который, например, откажется собирать код с неиспользуемыми переменными. Строгая типизация вынуждает выполнять все преобразования (даже алиасов на одни и те же типы) явным образом.

Также есть подробные гайды по стилизации кода и утилитаfmt, которая автоматически приводит код к общепринятому виду. Это объясняется тем, что на практике разработчики гораздо чаще читают код, чем пишут, и соглашения по стилизации помогают сэкономить много времени.

Давайте сравним реализации задачиFizzBuzz

на языкахC

иGo

.

Сейчас рассмотрим то же самое решение на Go.

Видно, что код стал «чище», избавился от круглых скобок и символа;. Вместе с тем имя главной функцииmain, обозначение комментариев и ключевые словаfor,if,elseостались такими же. В отличие от C, все переменные в Go сразу имеют начальные значения: например, переменные числовых типов равны 0, а строковые переменные содержат пустую строку.

Заметьте, что язык C не накладывает ограничения на использование фигурных скобок, а в языке Go открывающая фигурная скобка должна находиться в той же строке, что и конец объявления управляющих конструкций (func,for,ifи т. д.). Более того, даже однострочный блок кода необходимо заключать в фигурные скобки. 

Стандартная библиотека

Несмотря на компактность, стандартная библиотека Go позволяет решать большинство повседневных задач без обращения к сторонним библиотекам. В ней есть:

средства для простой и быстрой реализации серверов и клиентов (как TCP/UDP, так и HTTP);

пакеты для сериализации/десериализации данных в популярные форматы;

единый интерфейс для потокового ввода-вывода (пакетio);

вспомогательные интерфейсы и функции для обработки и оборачивания ошибок;

пакетtesting, предоставляющий инструменты для быстрого и удобного написания unit-тестов и бенчмарков из коробки;

свой язык шаблонов для кодогенерации и server-side-рендеринга HTML-страниц.

ООП

Парадигме ООП язык следует лишь частично, оставаясь мультипарадигмальным. Несколько ослабить строгую типизацию призван механизмinterface (интерфейс). Он даёт возможность задать ограничения на тип в виде списка методов, которые тот должен реализовывать.

При этом нет необходимости раскрывать и даже явным образом указывать конкретную реализацию. Типизация в этом случае работает по принципу«утиной» (duck typing): «если что-то плавает как утка, крякает как утка и летает как утка, то это, скорее всего, и есть утка». Достаточно реализовать набор методов у типа, чтобы он начал автоматически удовлетворять всем интерфейсам с аналогичными сигнатурами методов:

Напомним четыре признака объектно-ориентированного программирования:

Абстракция— возможность определить характеристики (свойства и методы) объекта, которые полностью описывают его возможности. В Go нет классов, но структуры с методами служат им неплохой заменой.

Инкапсуляция— возможность скрыть реализацию объекта, предоставив пользователю некую спецификацию (интерфейс) взаимодействия с ним. Go даёт возможность задать область видимости (публичные/приватные) методов структур и позволяет спрятать реализацию.

Наследование— возможность создания производных от родительского объекта, которые будут расширять или изменять свойства и поведение родителя. К сожалению, Go не реализует в полной мере механизм наследования, но есть встраивание — можно создавать типы на основе существующих.

Полиморфизм— возможность одному и тому же фрагменту кода работать с разными типами данных. Это происходит, когда объект может вести себя как другой объект. В Go нет полиморфизма в классическом понимании, однако похожие действия можно реализовать с помощью интерфейсов. Интерфейс определяет список методов, которые должен реализовывать тип, чтобы удовлетворять данному интерфейсу. Это ослабляет строгую типизацию и позволяет передавать в параметрах разные типы данных, поддерживающие один и тот же интерфейс.

Рассмотрим язык Go с точки зрения функционального программирования.

Функции высшего порядка— функции, которые могут в аргументах принимать другие функции и возвращать функции в качестве результата. В Go функции рассматриваются как значения и могут передаваться в другие функции, возвращаясь в виде результата.

Замыкания. Go позволяет определять и использовать функции, которые ссылаются на переменные своей родительской функции.

Чистые функции. В Go можно определять функции, которые зависят только от входящих аргументов и не влияют на глобальное состояние.

Рекурсия. Как и в большинстве языков, в Go можно применять рекурсивные вызовы функций.

Ленивые вычисления. В Go нет поддержки ленивых (отложенных) вычислений.

Иммутабельность переменных. В Go переменные могут изменять своё значение, поэтому иммутабельность (неизменяемость) переменных отсутствует.

Видно, что Go полностью не реализует парадигмы объектно-ориентированного и функционального программирования, но частично это компенсируется похожими возможностями. Поэтому Go считается мультипарадигмальным языком программирования.

Exceptions

Обработке ошибок в Go нашлось особое место. Во многих других языках ошибки обрабатываются с помощью механизма исключений (exceptions). Если в ходе выполнения функции происходит ошибка, выбрасывается специальное событие, называемое исключением, которое будет либо обработано тут же, в месте вызова функции, либо проброшено вверх по стеку, пока его кто-нибудь не поймает. Для «ловли» этого события нужна конструкцияtry — catch— обработчик исключений:

У этого подхода есть недостаток: выброс исключения происходит неявно для вызывающего функцию кода, поэтому программисту приходится запоминать, какая функция может выбросить исключение. Также существуют uncatchable-исключения — например, относящиеся к выходу программы за пределы доступной ей памяти.

В Go применяется другой подход, который вносит больше ясности в процесс обработки ошибок. Дело в том, что функции в Go могут возвращать больше одного значения. Этим свойством активно пользуются разработчики, используя в качестве последнего возвращаемого значения интерфейсerror:

Типerrorв Go — встроенный, то есть, чтобы им воспользоваться, не нужно импортировать какой-либо пакет. Наличие отдельного типа позволяет одинаково обрабатывать ошибки, независимо от того, с какой функцией вы работаете — стандартной или сторонней библиотеки. Вы всегда работаете с одним и тем же интерфейсомerror, а значит, можете сравнить две ошибки или применить к ним функции интроспекции ошибок из библиотекиerrors.

Так как возможность возникновения ошибки при выполнении функции отражена непосредственно в её сигнатуре (последнее возвращаемое значение имеет типerror), пользователь, который обращается к этой функции, вынужден всегда обрабатывать или игнорировать ошибку явно, иначе код не скомпилируется. Добавлять последним (обычно вторым) возвращаемым аргументом ошибку принято везде, где только может произойти ошибка. Чаще всего речь о функциях, в теле которых происходят операции ввода-вывода.
